# 构造函数
## 什么是构造函数
## 为什么要用构造函数，构造函数有什么好处
## 构造函数的具体实现

## 为什么要用构造函数，构造函数有什么好处
+ 封装
+ 继承
  + 为什么给函数定义方法和属性时，不直接通过this.的形式进行绑定，而要通过this.proptype.的形式进行绑定？<br>
  首先实例化对象都会有一个显式原型（prototype）和一个隐式原型（__proto__）。显式原型下挂载着当前对象中的一些属性，而隐式原型就是父级的显示原型，所以挂载的是父级实例化对象中的一些属性。<br>
  **注：因为子级的隐式原型就等于父级的显示原型，所以只有父级通过prototype定义的属性方法才能被子级通过__proto__调用到**
  ```js
    class Cat {}
    const a = new Cat()
    console.log(a.__proto__ === Cat.prototype)   // true
    // 这里new一个对象，就是一个继承的过程。从这里就可以看出 子级的隐式原型就等于父级的显示原型
  ```
  + constructor方法。显示原型下默认会有一个方法constructor，因为 Cat = Cat.prototype.constructor，所以该方法可以接收到实例化对象时传过来的参数，所以一般被用做构造器，用来初始化传过来的参数（将它绑定到this下）。
  > es6中会用到，es5使用function声明时，因为直接就可以在function Cat(props){}中接收到数据，所以不会见到
+ 多态